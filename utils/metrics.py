import torch
import numpy as np
import math



def log10(x):
	"""Convert a new tensor with the base-10 logarithm of the elements of x. """
	return torch.log(x) / math.log(10)

class Result(object):
	def __init__(self, mask_min, mask_max):
		self.irmse, self.imae = 0, 0
		self.mse, self.rmse, self.mae = 0, 0, 0
		self.absrel, self.lg10 = 0, 0
		self.delta1, self.delta2, self.delta3 = 0, 0, 0
		self.data_time, self.gpu_time = 0, 0
		self.mask_min = mask_min
		self.mask_max = mask_max

	def set_to_worst(self):
		self.irmse, self.imae = np.inf, np.inf
		self.mse, self.rmse, self.mae = np.inf, np.inf, np.inf
		self.absrel, self.lg10 = np.inf, np.inf
		self.delta1, self.delta2, self.delta3 = 0, 0, 0
		self.data_time, self.gpu_time = 0, 0

	def update(self, irmse, imae, mse, rmse, mae, absrel, lg10, delta1, delta2, delta3, gpu_time, data_time):
		self.irmse, self.imae = irmse, imae
		self.mse, self.rmse, self.mae = mse, rmse, mae
		self.absrel, self.lg10 = absrel, lg10
		self.delta1, self.delta2, self.delta3 = delta1, delta2, delta3
		self.data_time, self.gpu_time = data_time, gpu_time

	def evaluate(self, output, target):

		# not quite sure whether this is useful
		# target[target < self.mask_min] = self.mask_min
		# target[target > self.mask_max] = self.mask_max

		# valid_mask = np.logical_and(target > self.mask_min, target < self.mask_max)
		valid_mask = np.logical_and(target >= self.mask_min, target <= self.mask_max)
		output = output[valid_mask]
		target = target[valid_mask]

		abs_diff = (output - target).abs()
		diff = (output - target)

		self.mse = float((torch.pow(abs_diff, 2)).mean())
		self.rmse = math.sqrt(self.mse)
		self.rmselog = math.sqrt(float(((torch.log(target) - torch.log(output)) ** 2).mean()))

		self.mae = float(abs_diff.mean())
		self.lg10 = float((log10(output) - log10(target)).abs().mean())
		self.absrel = float((abs_diff / target).mean())
		self.sqrel = float(((diff ** 2) / target).mean())

		maxRatio = torch.max(output / target, target / output)
		self.delta1 = float((maxRatio < 1.25).float().mean())
		self.delta2 = float((maxRatio < 1.25 ** 2).float().mean())
		self.delta3 = float((maxRatio < 1.25 ** 3).float().mean())
		self.data_time = 0
		self.gpu_time = 0

		inv_output = 1 / output
		inv_target = 1 / target
		abs_inv_diff = (inv_output - inv_target).abs()
		self.irmse = math.sqrt((torch.pow(abs_inv_diff, 2)).mean())
		self.imae = float(abs_inv_diff.mean())

	def individual_results(self, output_all, target_all):
		B = target_all.shape[0]
		individual_results_t = torch.zeros((B, 7), dtype=torch.float32)
		for i in range(B):
			target = target_all[i]
			output = output_all[i]
			valid_mask = np.logical_and(target >= self.mask_min, target <= self.mask_max)
			output = output[valid_mask]
			target = target[valid_mask]

			abs_diff = (output - target).abs()
			diff = (output - target)

			mse = float((torch.pow(abs_diff, 2)).mean())
			rmse = math.sqrt(mse)
			rmselog = math.sqrt(float(((torch.log(target) - torch.log(output)) ** 2).mean()))

			mae = float(abs_diff.mean())
			# lg10 = float((log10(output) - log10(target)).abs().mean())
			absrel = float((abs_diff / target).mean())
			sqrel = float(((diff ** 2) / target).mean())

			maxRatio = torch.max(output / target, target / output)
			delta1 = float((maxRatio < 1.25).float().mean())
			delta2 = float((maxRatio < 1.25 ** 2).float().mean())
			delta3 = float((maxRatio < 1.25 ** 3).float().mean())
			# self.data_time = 0
			# self.gpu_time = 0

			# inv_output = 1 / output
			# inv_target = 1 / target
			# abs_inv_diff = (inv_output - inv_target).abs()
			# self.irmse = math.sqrt((torch.pow(abs_inv_diff, 2)).mean())
			# self.imae = float(abs_inv_diff.mean())

			individual_results_t[i, 0] = absrel
			individual_results_t[i, 1] = sqrel
			individual_results_t[i, 2] = rmse
			individual_results_t[i, 3] = rmselog

			individual_results_t[i, 4] = delta1
			individual_results_t[i, 5] = delta2
			individual_results_t[i, 6] = delta3

		return individual_results_t



class Result_withIdx(object):
	def __init__(self, mask_min, mask_max):
		self.irmse, self.imae = 0, 0
		self.mse, self.rmse, self.mae = 0, 0, 0
		self.absrel, self.lg10 = 0, 0
		self.delta1, self.delta2, self.delta3 = 0, 0, 0
		self.data_time, self.gpu_time = 0, 0
		self.mask_min = mask_min
		self.mask_max = mask_max

	def set_to_worst(self):
		self.irmse, self.imae = np.inf, np.inf
		self.mse, self.rmse, self.mae = np.inf, np.inf, np.inf
		self.absrel, self.lg10 = np.inf, np.inf
		self.delta1, self.delta2, self.delta3 = 0, 0, 0
		self.data_time, self.gpu_time = 0, 0

	def update(self, irmse, imae, mse, rmse, mae, absrel, lg10, delta1, delta2, delta3, gpu_time, data_time):
		self.irmse, self.imae = irmse, imae
		self.mse, self.rmse, self.mae = mse, rmse, mae
		self.absrel, self.lg10 = absrel, lg10
		self.delta1, self.delta2, self.delta3 = delta1, delta2, delta3
		self.data_time, self.gpu_time = data_time, gpu_time

	def evaluate(self, output, target, idx_tensor):
		# idx_tensor should have the same size as output and target

		valid_mask = np.logical_and(target > self.mask_min, target < self.mask_max)
		# print(valid_mask.shape, type(valid_mask))
		# print(valid_mask)
		# print(valid_mask.shape, idx_tensor.shape)
		final_mask = valid_mask & idx_tensor
		# print(final_mask.shape)
		output = output[final_mask]
		target = target[final_mask]

		abs_diff = (output - target).abs()
		diff = (output - target)

		self.mse = float((torch.pow(abs_diff, 2)).mean())
		self.rmse = math.sqrt(self.mse)
		self.rmselog = math.sqrt(float(((torch.log(target) - torch.log(output)) ** 2).mean()))

		self.mae = float(abs_diff.mean())
		self.lg10 = float((log10(output) - log10(target)).abs().mean())
		self.absrel = float((abs_diff / target).mean())
		self.sqrel = float(((diff ** 2) / target).mean())

		maxRatio = torch.max(output / target, target / output)
		self.delta1 = float((maxRatio < 1.25).float().mean())
		self.delta2 = float((maxRatio < 1.25 ** 2).float().mean())
		self.delta3 = float((maxRatio < 1.25 ** 3).float().mean())
		self.data_time = 0
		self.gpu_time = 0

		inv_output = 1 / output
		inv_target = 1 / target
		abs_inv_diff = (inv_output - inv_target).abs()
		self.irmse = math.sqrt((torch.pow(abs_inv_diff, 2)).mean())
		self.imae = float(abs_inv_diff.mean())


def miou(pred, target, n_classes=12):
	ious = []
	pred = pred.view(-1)
	target = target.view(-1)
	
	# Ignore IoU for background class ("0")
	for cls in range(0, n_classes):  # This goes from 1:n_classes-1 -> class "0" is ignored
		pred_inds = pred == cls
		target_inds = target == cls
		intersection = (pred_inds[target_inds]).long().sum().data.cpu()[0]  # Cast to long to prevent overflows
		union = pred_inds.long().sum().data.cpu()[0] + target_inds.long().sum().data.cpu()[0] - intersection
		if union == 0: ious.append(float('nan'))  # If there is no ground truth, do not include in evaluation
		else:ious.append(float(intersection) / float(max(union, 1)))
	return np.array(ious)


def im2col_sliding_broadcasting(A, BSZ, stepsize=1):
	# Parameters
	M,N = A.shape[0],A.shape[1]
	col_extent = N - BSZ[1] + 1
	row_extent = M - BSZ[0] + 1
	
	# Get Starting block indices
	start_idx = np.arange(BSZ[0])[:,None]*N + np.arange(BSZ[1])

	# Get offsetted indices across the height and width of input array
	offset_idx = np.arange(row_extent)[:,None]*N + np.arange(col_extent)

	# Get all actual indices & index into input array for final output
	return np.take (A,start_idx.ravel()[:,None] + offset_idx.ravel()[::stepsize])


def rgb2ycbcr(im):
	cbcr = np.empty_like(im)
	r = im[:,:,0]
	g = im[:,:,1]
	b = im[:,:,2]
	# Y
	cbcr[:,:,0] = .299 * r + .587 * g + .114 * b
	# Cb
	cbcr[:,:,1] = 128 - .169 * r - .331 * g + .5 * b
	# Cr
	cbcr[:,:,2] = 128 + .5 * r - .419 * g - .081 * b
	return cbcr # np.uint8(cbcr)

def ycbcr2rgb(im):
	rgb = np.empty_like(im)
	y   = im[:,:,0]
	cb  = im[:,:,1] - 128
	cr  = im[:,:,2] - 128
	# R
	rgb[:,:,0] = y + 1.402 * cr
	# G
	rgb[:,:,1] = y - .34414 * cb - .71414 * cr
	# B
	rgb[:,:,2] = y + 1.772 * cb
	return rgb # np.uint8(rgb)


def img_greyscale(img):
	return 0.299 * img[:,:,0] + 0.587 * img[:,:,1] + 0.114 * img[:,:,2]
